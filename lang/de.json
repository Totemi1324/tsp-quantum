{
    "tab-0": "Lektionen",
    "tab-1": "Demo",
    "tab-2": "Downloads",
    "lesson_page": {
        "p-0": "Wenn wir lange Strecken zurücklegen müssen, wollen wir so schnell wie möglich von einem Ort zum anderen gelangen. Vor dieser Herausforderung der effektiven Routenplanung standen und stehen die Menschen vor langer Zeit ebenso wie heute. Aber kann uns die Quantenphysik diese Arbeit abnehmen?",
        "p-1": "Dieser Kurs ist ein umfassender Leitfaden zum quantenmechanischen Ansatz für dieses bekannte Optimierungsproblem. Du wirst lernen:",
        "p-2": "Weitere Informationen findest du im",
        "li-0": "Was Graphen sind und wie man mit ihnen rechnet",
        "li-1": "Wie QUBO-Probleme konstruiert sind",
        "li-2": "Wie das Traveling-Salesman-Problem als Hamilton-Matrix für Quantenannealer dargestellt werden kann",
        "li-3": "Was die Vor- und Nachteile dieser Methode sind",
        "li-4": "Wie du Wegfindung bei deinen eigenen Graphen durchführen kannst",
        "Link": "GitHub-Repository des Projekts",
        "strong": "Viel Spaß beim Lernen!",
        "h2-0": "Kapitel 1",
        "h2-1": "Kapitel 2",
        "h2-2": "Kapitel 3",
        "h2-3": "Kapitel 4",
        "h2-4": "Kapitel 5"
    },
    "demo_page": {
        "p-0": "Dieser Teil der Website befindet sich derzeit im Aufbau. Sei gespannt!"
    },
    "download_page": {
        "p-0-1": "Hier findest du alle Dateien rund um diesen Kurs und dem TSPquantum-Projekt zum kostenlosen Download. Wenn du nicht finden kannst, was du suchst oder an zusätzlichen Daten interessiert bist, sende bitte deine Anfrage an ",
        "p-0-2": ". Alle folgenden Dateien sind nur für forschungsbezogene und nicht-kommerzielle Zwecke bestimmt. Eine unerlaubte Veröffentlichung und/oder Vervielfältigung auf anderen Plattformen ist untersagt, sofern nichts anderes angegeben ist.",
        "h2-0": "Downloadbereich",
        "h3-0": "Anwendungen",
        "h3-1": "Sonstige"
    },
    "lesson-BxESn": {
        "h2-0": "Das Traveling Salesman-Problem: Eine Einführung",
        "p-0": "Du bist der Vertreter eines großen Unternehmens, welches dich auf eine Geschäftsreise durch seine wichtigsten Standorte schickt. Zufälligerweise befinden sich diese in den acht größten Städten Deutschlands<sup>1</sup>. Du willst natürlich so viel Zeit wie möglich sparen. Wenn du von Berlin aus startest, jede Stadt genau einmal besuchst und anschließend nach Berlin zurückkehrst, in welcher Reihenfolge solltest du die Städte besuchen, um die Reise so kurz wie möglich zu halten?",
        "p-1": "Das ist die Frage, mit der sich das Traveling Salesman-Problem (zu deutsch: \"Problem des Handelsreisenden\" beschäftigt. Oder, allgemeiner ausgedrückt:",
        "p-2": "Bei solch einfachen Aufgaben ist die Lösung natürlich schnell ersichtlich: Nimmt man die Entfernungen als Luftlinien an, so wäre der kürzeste Weg derjenige, der wie gezeigt außen herum führt. Wenn man jedoch 20, 50 oder gar 100 Städte besuchen muss, ist die Sache gar nicht mehr so einfach.",
        "p-3-0": "Das <i>Traveling Salesman-Problem</i> (kurz <i>TSP</i>) ist in zahlreichen realen Anwendungen zu finden, z.B. bei der Planung von Lieferketten, der Renovierung von Pipelines oder der Strukturanalyse von Kristallen. Entsprechend wichtig ist eine schnelle und zuverlässige Lösungsmethode. Der Haken daran: Die Anzahl der möglichen Wege, welche sich nach der Formel",
        "p-3-1": "berechnen lässt, ist immens und wächst mit jeder weiteren Stadt rasant. In unserem Beispiel mit 8 Städten haben wir <span class=\"emphasis\">2520</span> Möglichkeiten zur Auswahl, aber mit 12 Städten gibt es bereits <span class=\"emphasis\">19.958.400</span> verschiedene Wege. Daher ist das Problem NP-schwer, was im Grunde bedeutet, dass ein Algorithmus, der die exakte Lösung für große Eingaben in endlicher Zeit findet, wahrscheinlich unmöglich ist.",
        "p-4": "Das TSP ist ein gutes Beispiel für ein \"Optimierungsproblem\". Da wir ohne jahrzehntelange Rechenzeiten nicht alle Lösungen durchprobieren und die beste Lösung nicht endgültig berechnen können, versuchen wir, uns ihr so gut wie möglich anzunähern. Es ist möglich, das <i>\"globale\" Optimum</i>, den kürzesten Weg von allen, zu finden, aber wir können genauso gut bei einem <i>\"lokalen\" Optimum</i>, einem der vielen kürzeren Wege, zu landen. Quantenannealer, eine Unterkategorie von Quantencomputern, sind aufgrund der physikalischen Eigenschaften von Qubits wie geschaffen für diese Aufgabe. Außerdem sind herkömmliche Optimierungsalgorithmen langsam, während ein Quantenannealer seine Lösung in nur wenigen Mikrosekunden findet. In diesem Kurs werden wir untersuchen, wie die Quantenannealer von D-Wave das TSP berechnen und ob wir bessere Lösungen als mit traditionellen Methoden finden können.",
        "strong-0": "\"Wie lautet die kürzeste mögliche Route, die jede Stadt genau einmal besucht und zur Ausgangsstadt zurückführt, wenn eine Liste von Städten und die Entfernungen zwischen jedem Städtepaar gegeben ist?\"",
        "h3-0": "Warum ein quantenmechanischer Ansatz?",
        "i-0": "Wie kann man das tiefste Tal finden, wenn man nur einen Punkt auf einmal sieht? Ein Beispiel für Optimierungsprobleme"
    },
    "lesson-Z30Ce": {
        "h2-0": "Graphentheorie",
        "p-0": "Computer können nur mit Zahlen arbeiten, also müssen wir auch mit ihnen umgehen. Wir haben bereits unbewusst ein Schlüsselkonzept der Lösungsmethode gezeichnet mit den Städten, die durch Linien miteinander verbunden sind: <i>Graphen</i> sind ein grundlegender Bestandteil der Mathematik, und zwar so sehr, dass sie ein eigenes Fachgebiet namens <i>Graphentheorie</i> besitzen. Im Allgemeinen beschreibt ein Graph eine Menge von Städten, <i>\"Knoten\"</i> genannt, und wie sie mathematisch miteinander verbunden sind.",
        "p-1": "Vereinfachen wir unser Beispiel aus der vorherigen Lektion auf nur 4 Städte mit dem Namen A, B, C und D.",
        "p-2": "Jeder Knoten wird als blauer Kreis dargestellt, der mit anderen Knoten durch <i>\"Kanten\"</i>, verbunden ist, wobei die Abstände zwischen den Knoten in grau notiert sind. In unserem Beispiel ist jedes mögliche Knotenpaar miteinander verbunden, jede Kante kann in beide Richtungen durchlaufen werden und jeder Kante ist ein eindeutiger Distanzwert zugewiesen. Dies wird als <strong>vollständiger, ungerichteter und gewichteter Graph</strong> bezeichnet. Graphen können verschiedene Arten und Formen annehmen, aber in diesem Tutorial konzentrieren wir uns nur auf diese eine Kategorie, da er der Standarddefinition des TSP entspricht.",
        "p-3": "Mathematisch gesehen lässt sich ein solcher Graph wie folgt charakterisieren:",
        "p-4": "wobei",
        "p-5": "Das war ziemlich viel auf einmal. Gehen wir es Schritt für Schritt durch:",
        "p-6": "Der obige Graph kann also wie folgt beschrieben werden:",
        "p-7": "Die Aufgabe jedes TSP-Algorithmus ist es, einen Pfad zu finden, der jeden Knoten genau einmal besucht und zum Startknoten zurückkehrt (auch <i>Hamiltonkreis</i> genannt), wobei die Summe der Distanzen aus der Distanzfunktion so gering wie möglich ist.",
        "i-0": "Vollständiger Graph mit 4 Knoten",
        "li-0": "Ein Graph <span class=\"emphasis\">G</span> besteht aus drei Komponenten: <span class=\"emphasis\">V</span>, die Knoten (von Englisch \"vertices\"), <span class=\"emphasis\">E</span>, die Kanten (von Englisch \"edges\"), und <span class=\"emphasis\">d</span>, die Distanzfunktion. Die Notation mit <span class=\"emphasis\">()</span> als ein Tripel verdeutlicht, dass sie zusammengehören.",
        "li-1": "<span class=\"emphasis\">V</span> bezeichnet die Menge der Knoten, aus denen ein Graph besteht. Mengen erkennt man an den geschweiften Klammern <span class=\"emphasis\">&#123;&#125;</span>.",
        "li-2": "<span class=\"emphasis\">E</span> ist die Menge der Kanten, dargestellt als nicht geordnete Knotenpaare &#123;v<sub>i</sub>, v<sub>j</sub>&#125;. Der senkrechte Strich <span class=\"emphasis\">|</span> definiert, welche Bedingungen diese Paare erfüllen müssen: Sowohl v<sub>i</sub> als auch v<sub>j</sub> müssen Teil von V<sup>2</sup> sein (\"quadrieren\" steht in der Mengenschreibweise für das kartesische Produkt, d.h. die Menge aller möglichen Kombinationen der Elemente einer Menge) <strong>und</strong> v<sub>i</sub> darf nicht gleich v<sub>j</sub> sein, um Schleifen zu vermeiden.",
        "li-3": "<span class=\"emphasis\">d</span> ist eine Funktion, die jeder Kante (also einem ungeordneten Paar von Knoten) eine reelle Zahl zuordnet, in diesem Fall die Länge."
    },
    "lesson-m2MJl": {
        "h2-0": "QUBO-Probleme",
        "p-0": "Bevor wir uns mit der Funktionsweise von Quantenannealern befassen können, müssen wir ein grundlegendes Konzept verstehen. Damit ein Quantenannealer eine Aufgabe lösen kann, muss diese als <strong>quadratic unconstrained binary optimization-Problem</strong>, oder kurz <strong>QUBO-Problem</strong> formuliert werden. Das ist nicht besonders hilfreich, also lasst es uns etwas aufschlüsseln:",
        "p-1": "Die QUBO-Form ist ein weiteres mathematisches Konstrukt, das dem Quantenannealer hilft, die physikalischen Eigenschaften seiner Qubits zu nutzen. Betrachten wir ein Beispiel, um das Konzept zu veranschaulichen.",
        "p-2": "Dieses Dame-Brett der Größe 2x2 hat die vier Felder <span class=\"emphasis\">a</span>, <span class=\"emphasis\">b</span>, <span class=\"emphasis\">c</span> und <span class=\"emphasis\">d</span>. Zusätzlich gibt es vier Spielsteine, von denen jeder auf ein beliebiges Feld gesetzt werden kann, aber nicht muss (jedoch nicht mehrere auf dasselbe Feld). Wenn ein Feld besetzt ist, wird es als <strong>1</strong> dargestellt, ansonsten als <strong>0</strong>. Der Quantencomputer soll die Steine so platzieren, dass möglichst viele Felder besetzt sind.",
        "p-3-0": "Wir erinnern uns: Ein Computer braucht Zahlen. Gibt es einen Weg, um festzustellen, wie gut eine bestimmte Lösung ist? Alle Optimierungsprobleme erfordern eine <strong>Kostenfunktion</strong>, die die Korrektheit einer Lösung bewertet: Je niedriger die Kosten, desto besser. Nun hat sich unser Ziel von der Suche nach der besten Lösung auf die Minimierung der Kostenfunktion verlagert. Wenn wir ein QUBO-Problem haben, das vier Variablen <span class=\"emphasis\">a</span>, <span class=\"emphasis\">b</span>, <span class=\"emphasis\">c</span> und <span class=\"emphasis\">d</span> (die entweder 0 oder 1 sind) als Eingabe nimmt, ist die Kostenfunktion wie folgt definiert:",
        "p-3-1": "Zunächst summieren wir die Werte aller Felder, dann addieren wir das Produkt jedes möglichen <i>Paares</i> der Feldwerte. Die <span class=\"emphasis\">h</span>, mit denen die Feldwerte multipliziert werden, sind einfache Koeffizienten, d.h. reelle Zahlen, die steuern, wie stark wir die einzelnen Belegungen belohnen (oder bestrafen) wollen. Dies ist ein ziemlich cleveres System: Ist ein Feld unbesetzt, also 0, wird der entsprechende Koeffizient aus der Gleichung entfernt. Ähnlich verhält es sich bei den Feldpaaren: Eine Belohnung bleibt nur in der Gleichung, wenn beide Felder 1 sind. Da wir nach den niedrigsten Kosten suchen, bedeutet <span class=\"emphasis\">h &#60; 0</span> \"Belohnung\", <span class=\"emphasis\">h &#62; 0</span> \"Strafe\" und <span class=\"emphasis\">h = 0</span> \"irrelevant\". Ein Beispiel: Wenn wir unbedingt wollen, dass <span class=\"emphasis\">a</span> besetzt ist, können wir ihm ein <span class=\"emphasis\">h</span> von z.B. -10 geben, oder wenn wir verhindern wollen, dass <span class=\"emphasis\">b</span> und <span class=\"emphasis\">c</span> gleichzeitig besetzt sind, sollte <span class=\"emphasis\">h</span> eine hohe positive Zahl wie 25 sein.",
        "p-4-0": "Nun können wir ein QUBO-Problem für unsere ursprüngliche Aufgabe definieren: Es sollen so viele Felder wie möglich besetzt werden.",
        "p-4-1": "Wir können darauf verzichten, die Werte von Felderpaaren zu berechnen, da die Beziehungen zwischen den Feldern für dieses Problem irrelevant sind. Dies ist eine gültige Kostenfunktion, denn die niedrigsten Kosten, -4, werden nur erreicht, wenn alle Felder 1 sind. Fügen wir die folgende Bedingung zu unserer Aufgabe hinzu: Die Felder <span class=\"emphasis\">a</span> und <span class=\"emphasis\">b</span> dürfen <strong>nicht</strong> gleichzeitig belegt sein.",
        "p-4-2": "Wenn <span class=\"emphasis\">a</span> und <span class=\"emphasis\">b</span> beide 1 sind, sind die Kosten 0, auch wenn alle Felder für die maximale Belohnung besetzt sind, was bedeutet, dass die Lösung schlechter ist als alle anderen möglichen Lösungen. Die besten erreichbaren Kosten sind hier also -3, was die richtige Lösung liefert. Eine weitere praktische Strategie bei QUBO-Problemen ist das <i>Quadrieren</i>, zum Beispiel bei der Aufgabe \"Genau <ins>zwei von vier</ins> Feldern sollten besetzt sein\":",
        "p-4-3": "Das funktioniert, weil bei der Summierung aller Felder und der Subtraktion von 2 das Ergebnis genau dann 0 ist, wenn genau zwei Felder 1 sind. Aber: Wenn kein Feld oder ein Feld besetzt ist, wäre das Ergebnis negativ, was ein noch besseres Ergebnis ergeben würde. Dies kann durch das Quadrieren der Gleichung behoben werden, denn wenn eine negative Zahl quadriert wird, ergibt sich immer ein positiver Wert. Die quadrierten Variablen wie <span class=\"emphasis\">a<sup>2</sup></span>, <span class=\"emphasis\">b<sup>2</sup></span> usw., die sich aus dem Ausmultiplizieren der Gleichung ergeben, wären eigentlich nicht zulässig (da gegen die Regeln von QUBO), aber da im Falle von Binärzahlen <span class=\"emphasis\">x<sup>2</sup>=x</span> gilt, können sie durch <span class=\"emphasis\">a</span>, <span class=\"emphasis\">b</span> usw. ersetzt werden. Auch Konstanten wie +4 können weggelassen werden, da sie nur alle Ergebnisse um den gleichen Betrag nach oben oder unten verschieben. Wir können überprüfen, ob unsere Kostenfunktion korrekt ist, indem wir sie mit verschiedenen Eingaben testen:",
        "p-5": "Hier sind einige weitere Beispiele für QUBO-Gleichungen:",
        "li-0": "<i>Quadratic</i> (quadratisch) bedeutet, dass maximal zwei Variablen miteinander multipliziert werden können.",
        "li-1": "<i>Unconstrained</i> (uneingeschränkt) bedeutet, dass die richtige Antwort nicht durch andere Bedingungen eingeschränkt ist.",
        "li-2": "<i>Binary</i> (binär) bedeutet, dass wir nur 0 oder 1 eingeben können.",
        "li-3": "<i>Optimization</i> (Optimierung) ist – wenn du dich an die vorangegangenen Lektionen erinnerst – der Prozess, die optimale Lösung für ein komplexes Problem durch Annäherung zu finden.",
        "li-4": "Es sollten so viele Felder wie möglich leer sein.",
        "li-5": "Es sollte <ins>nicht mehr als ein</ins> Feld belegt sein. (D.h.: Genau null Felder oder ein Feld sollte belegt sein.)",
        "li-6": "In jeder Zeile und jeder Spalte sollte <ins>exakt ein</ins> Feld belegt sein.",
        "i-0": "Anmerkung: Das folgende ist nur eine mögliche Form von QUBO-Problemen, aber da es dem TSP am nächsten kommt, ist es das einzige, das in diesem Kurs behandelt wird. Es gibt auch noch andere Möglichkeiten, einen Quantenannealer zu programmieren, wie z.B. Ising-Probleme, die wir der Kürze und Verständlichkeit halber auslassen werden."
    },
    "lesson-xR66u": {
        "h2-0": "Wie funktionieren Quantenannealer?",
        "p-0": "Mit den mathematischen Grundlagen ausgestattet, können wir uns nun der Frage stellen: Wie kommen wir von einer Eingabe zu einem Ergebnis? Der Prozess der Programmierung eines Quantenannealers unterscheidet sich stark von dem eines herkömmlichen Computers, da dieser nur mit reellen Zahlen und nicht mit Anweisungen oder Codezeilen arbeitet. Hier ist eine Darstellung dieses Vorgangs:",
        "p-1": "Das sieht vielleicht etwas verwirrend aus, gehen wir es also Schritt für Schritt durch.",
        "p-2-0": "Um unsere Daten darzustellen, benötigen wir noch ein weiteres mathematisches Konstrukt. In seiner traditionellen Form ist ein Vektor eine Größe im Raum mit einer Richtung und Länge (oft als Pfeil oder Strahl dargestellt)<sup>1</sup> und besteht aus zwei oder mehr Koordinaten, die in einer vertikalen Spalte untereinander geschrieben werden. Ein Vektor im 3-dimensionalen Raum würde zum Beispiel drei Koordinaten enthalten:",
        "p-2-1": "Da ein Vektor im Grunde eine Zahlenreihe ist, können wir Vektoren verwenden, um unsere Ergebnisse aus dem Quantenannealer abzurufen. Wenn wir ein 4x4-Spielbrett mit 4<sup>2</sup>=16 Feldern hätten, würden die Einträge angeben, ob unsere Felder <span class=\"emphasis\">a</span>, <span class=\"emphasis\">b</span>, usw. bis <span class=\"emphasis\">n</span> besetzt (1) oder unbesetzt (0) sein sollten. Dies wird als der <strong>Antwortvektor q<sub>A</sub></strong> definiert.",
        "p-2-2": "In ähnlicher Weise kann man sich eine <i>Matrix</i> als eine Reihe von zusammengeklebten Vektoren vorstellen. Es handelt sich um ein rechteckiges Feld von Zahlen, bei dem jedes Element im Format <span class=\"emphasis\">a<sub>ij</sub></span> indiziert ist (<span class=\"emphasis\">i</span> und <span class=\"emphasis\">j</span> bezeichnen den Zeilen- und Spaltenindex eines bestimmten Elements).",
        "p-3": "Ein Beispiel: Das Element a<sub>31</sub> der obigen Matrix ist 5.",
        "p-4-0": "Keine Angst, wenn es noch nicht ganz klar ist, wir werden Matrizen nur als einfaches Mittel zum Zweck verwenden. Erinnerst du dich an die QUBO-Gleichungen aus der vorherigen Lektion? In der Tat sind Matrizen die einzige Möglichkeit, diese als Eingabe an den Quantenannealer zu übermitteln. Da die Form der QUBO-Gleichungen immer gleich ist, können wir die Koeffizienten (die einzigen Werte, die sich ändern) in einer Matrix im folgenden Format zusammenfassen, um eine Abstraktion der Definition unseres Problems zu erstellen:",
        "p-4-1": "Dies ist die Definition der <strong>Hamilton-Matrix H</strong>, oder einfach nur <strong>Hamiltonian</strong>. In ihrer Hauptdiagonale (die Felder, in denen <span class=\"emphasis\">i</span> und <span class=\"emphasis\">j</span> gleich sind) befinden sich die Koeffizienten der einzelnen Felder und daneben die der Verbindungen zu anderen Feldern. Da die untere Hälfte leer bleibt und mit Nullen gefüllt ist, gehört der Hamiltonian zum Typ der <i>oberen Dreiecksmatrizen</i>. Nehmen wir unser \"Brettspiel\"-Beispiel aus der vorigen Lektion mit dem QUBO-Problem \"Genau zwei von vier Feldern sollten besetzt sein\", so ergibt sich der Hamiltonian:",
        "p-5-0": "Wir haben ja gesagt, dass ein Quantenannealer versucht, den Antwortvektor zu finden, dessen Koordinaten die geringsten Kosten verursachen. Da wir die Kostenfunktion, die unser QUBO-Problem darstellt, in eine Matrix komprimiert haben, kann die Operation wie folgt umformuliert werden<sup>2</sup>:",
        "p-5-1": "Das sieht komplizierter aus, als es ist, und sagt uns nur, dass wir die Kosten <span class=\"emphasis\">C</span> minimieren wollen, die aus zwei Summen bestehen: Den Produkten jedes Koeffizienten <span class=\"emphasis\">a<sub>i</sub></span> mit seinem jeweiligen Feld <span class=\"emphasis\">q<sub>i</sub></span> und den anderen Koeffizienten <span class=\"emphasis\">b<sub>ij</sub></span> mit einem beliebigen Paar von zwei Feldern <span class=\"emphasis\">q<sub>i</sub></span> und <span class=\"emphasis\">q<sub>j</sub></span>. Alternativ können wir die Operation als eine Matrixmultiplikation betrachten, wobei der Hamiltonian von rechts mit dem Antwortvektor und von links mit dem transponierten (d.h. horizontal ausgelegten) Antwortvektor multipliziert wird.",
        "p-6": "Aber wie funktioniert ein Quantenannealer im Inneren? Dies ist ein komplizierteres Thema, das wir hier nur oberflächlich behandeln können, ohne über fortgeschrittene Kenntnisse der Quantenphysik zu verfügen.",
        "p-7": "Das Herzstück eines Quantencomputers ist die <i>QPU</i> (Quantum Processing Unit<sup>3</sup>), ein wenige Quadratzentimeter großer Chip, der mit den quantenmechanischen Gegenstücken der Bits, den <i>Qubits</i>, besetzt ist. Im Gegensatz zu klassischen Computern werden diese nicht mit Transistoren, sondern mit Elementarteilchen eines bestimmten Spins realisiert, die nach den Regeln der Quantenphysik gleichzeitig zwei Zustände (<i>spin up</i> und <i>spin down</i>) annehmen können, bis sie gemessen werden. Aus diesem Zustand, der <i>Superposition</i> genannt wird, schöpfen Quantencomputer ihre potenziell enorme Rechenleistung.",
        "p-8": "Das aktuelle Modell <i>D-Wave Advantage</i> hat genau 5627 Qubits. Diese sind mit sogenannten <i>Kopplern</i> miteinander verbunden, die es den Qubits ermöglichen, miteinander zu interagieren. Die Anzahl der Koppler pro Qubit bestimmt letztlich die Rechenleistung des Annealers.",
        "p-9": "Diese Koppler bestehen aus Magnetfeldern, die individuell eingestellt werden können, so dass nach einer Messung ein Qubit mit größerer Wahrscheinlichkeit <span class=\"emphasis\">1</span> oder <span class=\"emphasis\">0</span> wird und Paare von Qubits mit größerer Wahrscheinlichkeit gleiche oder ungleiche Werte annehmen. Wenn der Quantenglätter einen Hamiltonian erhält, stellt er mit den Koeffizienten <span class=\"emphasis\">a<sub>i</sub></span> und <span class=\"emphasis\">b<sub>ij</sub></span> die Stärke dieser Magnetfelder, auch <i>Bias</i> genannt, ein. Damit der Annealer funktioniert, muss die QPU auf eine Temperatur nahe dem absoluten Nullpunkt (16mK, ca. -273,1°C) gekühlt werden. Durch einen Effekt, der als <i>Quantentunneleffekt</i> bekannt ist, versuchen die Qubits in diesem System, den Zustand mit der niedrigsten Energie anzunähern, der durch die Programmierung der Koppler gleichzeitig die beste Lösung für das ursprüngliche Optimierungsproblem darstellt. Das ist der Grund, warum eine Kostenfunktion benötigt wird: Sie bestimmt den Zustand der \"niedrigsten Kosten\" (oder \"niedrigster Energie\").",
        "h3-0": "Vektoren und Matrizen",
        "h3-1": "Das Innenleben",
        "strong-0": "Herzlichen Glückwunsch! Du weißt jetzt, wie ein Quantenannealer Aufgaben löst.",
        "i-0": "Die Diagramme der (a) Chimera-Architektur des D-Wave 2000Q und der neueren (b) Pegasus-Architektur zeigen die Unterschiede zwischen den Strukturen der QPUs. (a) hat 6 Koppler/Qubit, (b) 15 Koppler/Qubit"
    },
    "lesson-yV8O6": {
        "h2-0": "Umwandlung des Traveling Salesman-Problems für Quantenannealer",
        "p-0": "Nun sind wir beim Hauptteil des Kurses angelangt. Die Erstellung eines Quantenlösungsverfahrens für das TSP ist ein spannendes Beispiel für die Vielseitigkeit der Quanteninformatik und ein Demonstration, wie sie zur Verbesserung alltäglicher Aufgaben beitragen kann. Der erste Schritt in Richtung einer solchen Methode ist die Frage, wie man die Kernkomponente des TSP, den Graphen, in ein QUBO-Problem umwandelt.",
        "p-1": "Wie in den vorangegangenen Lektionen gezeigt, lassen sich QUBO-Probleme am einfachsten durch ein quadratisches Feld mit nummerierten Zellen erstellen. Betrachten wir die einfachste Instanz des TSP, einen Graphen mit vier Städten (da dies die minimale Anzahl von Eckpunkten ist, die andere Lösungen als das Optimum zulässt):",
        "p-2": "Wenn wir <span class=\"emphasis\">A</span> als Ausgangspunkt nehmen, ist unsere Tour hier <strong>A ➞ B ➞ D ➞ C ➞ A</strong> (natürlich ist auch der umgekehrte Weg A ➞ C ➞ D ➞ B ➞ A gültig). Wie kann man diese Datenstruktur in ein Zahlenfeld umwandeln?",
        "p-3": "Eine mögliche Tour ist durch zwei Angaben definiert:",
        "p-4": "Mit Hilfe einer Matrix (der Struktur, die zuvor behandelt wurde), lässt sich der erste Punkt angehen. Auf den obigen Graphen angewandt, ergibt sich folgende Tabelle:",
        "p-5": "Die Zeilen repräsentieren die einzelnen Städte, während die Spalten die \"Zeitpunkte\", d.h. die einzelnen Schritte, markieren. Ein Eintrag von <span class=\"emphasis\">1</span> im Feld <span class=\"emphasis\">a<sub>ij</sub></span> bedeutet, dass die <span class=\"emphasis\">i</span>-te Stadt im <span class=\"emphasis\">j</span>-ten Zeitschritt besucht wird. Die fünfte Spalte würde die Rückkehr zur Ausgangsstadt markieren, aber da sie immer eine exakte Kopie der ersten Spalte wäre, kann sie weggelassen werden, um die Datenmenge zu minimieren. Nun haben wir eine Abstraktion geschaffen, die auf Touren in Graphen beliebiger Größe angewendet werden kann. Nennen wir diese neue Struktur <i>Tourmatrix</i>.",
        "p-6": "Vielleicht siehst du schon, worauf das hinausläuft: In der Tat sieht dies sehr ähnlich aus wie das \"Dame\"-Beispiel aus Kapitel 2. Du kannst dir die <span class=\"emphasis\">1</span>en als Spielsteine vorstellen, die auf ein Spielbrett gelegt werden können, um zu markieren, welche Stadt zu welchem Zeitschritt gehört. Als Nächstes werden wir daraus ableiten, wie man die QUBO-Gleichung extrahiert.",
        "h3-0": "Die Tourmatrix",
        "li-0": "Die chronologische Reihenfolge der besuchten Städte",
        "li-1": "Die Gesamtkosten der Route, d.h. die Summe der Länge der Kanten, die befahren werden"
    },
    "lesson-0nRrT": {
        "h2-0": "Formulierung der QUBO-Gleichung",
        "p-0": "Aus der beispielhaften Tourmatrix der vorigen Lektion lassen sich folgende Regeln für die Belegung ableiten:",
        "p-1": "In diesem 4x4-Gitter sind die Zellen in alphabetischer Reihenfolge benannt. Für vier Städte wird die QUBO-Gleichung wie folgt formuliert:",
        "p-2": "Dies ist eine lange und unhandliche Gleichung, aber eine gültige Kostenfunktion, da nur die gültigen Belegungen die niedrigsten Kosten verursachen. Da sie von <i>n</i>, der Anzahl der Städte, abhängt, benötigt die QUBO-Gleichung <i>n<sup>2</sup></i> Variablen als Eingabe (was bedeutet, dass sie quadratisch wächst) und muss für jede einzelne TSP-Instanz neu formuliert werden. Aber das ist nur die halbe Miete. Um die zweite Schlüsselinformation von Touren zu quantifizieren, müssen auch die Streckenkosten in der QUBO-Gleichung berücksichtigt werden. Da es sich dabei glücklicherweise ebenfalls um eine Kostenfunktion handelt, können die Werte übernommen und zu den Gesamtkosten addiert werden. Aber wie bestimmt man, welche Werte man wann hinzufügt? Betrachte das folgende Beispiel:",
        "p-3-0": "Eine bestimmte Kante wird genau dann befahren, wenn ihr Anfangsknoten in einer Spalte und ihr Zielknoten in der folgenden Spalte markiert ist. Die Pfeile stellen hier alle Kanten dar, die von <span class=\"emphasis\">B</span> zu den anderen Knoten führen. Da wir anfangs nicht wissen, wann wir <span class=\"emphasis\">B</span> besuchen werden, muss dies für alle Zeitschritte wiederholt werden. Die Kante <span style=\"text-decoration: overline\">BA</span> mit den Kosten von 6,6 entspricht zum Beispiel <span class=\"emphasis\">(e, b)</span>, <span class=\"emphasis\">(f, c)</span>, <span class=\"emphasis\">(g, d)</span> und <span class=\"emphasis\">(h, a)</span>. Wenn wir den Kostenbetrag mit diesen Variablenpaaren multiplizieren (dies ist mit den Regeln von QUBO-Problemen vereinbar), wird sie nur addiert, wenn beide Felder besucht werden, d.h. gleich <span class=\"emphasis\">1</span> sind. Außerdem besteht keine Gefahr, die Kosten für eine bestimmte Kante mehr als einmal zu addieren, denn da es verboten ist, eine Stadt mehr als einmal zu besuchen, wird, wenn überhaupt, nur einer dieser vier Fälle eintreten. So sieht also die zweite Hälfte der QUBO-Gleichung aus:",
        "p-3-1": "Dieser Teil wird einfach zum Rest der Gleichung hinzugefügt und muss ebenfalls für jede TSP-Instanz neu generiert werden. Diese Kostenfunktion sollte nun die beste (niedrigste) Energie liefern, wenn die formalen Regeln der Belegung, d.h. 1/Zeile und 1/Spalte, erfüllt sind <i>und</i> der Quantenannealer diejenigen Verbindungen auswählt, deren Summe gemäß den TSP-Anforderungen minimal ist (behalte diese Aussage im Hinterkopf; wir werden in der nächsten Lektion erörtern, warum dies nicht so einfach ist).",
        "li-0": "Es ist genau eine Belegung pro Zeile erlaubt (da es nicht möglich ist, eine Stadt mehr als einmal zu besuchen)",
        "li-1": "Es ist genau eine Belegung pro Spalte erlaubt (da es nicht möglich ist, mehrere Städte gleichzeitig zu besuchen)",
        "strong-0": "Wir haben das Traveling Salesman-Problem erfolgreich in ein Quantenannealer-kompatibles QUBO-Problem verwandelt!"
    },
    "lesson-EFTOp": {
        "h2-0": "Von Koeffizienten zur Hamilton-Matrix",
        "p-0-0": "Es ist Zeit, die Lösung zusammenzusetzen: Wie in Kapitel 2 besprochen, müssen die Koeffizienten aus der QUBO-Gleichung in die Hamilton-Matrix übertragen werden, um eine gültige Eingabe für den Quantenannealer zu sein. Das Ergebnis unserer Berechnungen ist eine ziemlich umfangreiche Matrix der Größe 16x16, aus der hier ein Auszug dargestellt ist:",
        "p-0-1": "Die Aufgabe ist also gelöst, oder? Leider nicht ganz. Es gibt noch etwas, worüber wir reden müssen: die Skalierung. Wenn wir versuchen, diesen Hamiltonian an den Quantenannealer zu senden, ergibt sich folgendes Bild:",
        "p-1-0": "Die Tabelle zeigt die Top 5 aus den Ergebnissen des D-Wave-Annealers (sortiert vom besten zum schlechtesten Ergebnis). Alle davon besuchen nur drei oder noch weniger Städte. Das liegt daran, dass die Koeffizienten, die den Annealer zwingen, die Regel \"Genau eine Belegung pro Zeile/Spalte\" zu befolgen, -2 oder 2 sind und daher zu klein im Vergleich zu den Entfernungen zwischen den Knoten, die zwischen 3 und 7 liegen. Wenn der Annealer weniger Zellen belegt, überwiegt die Energie, die er durch das Weglassen von Kanten spart, bei weitem die Strafe, die er für den Besuch weniger Städte erhält. Um dieses Problem zu lösen, müssen wir unsere Koeffizienten entsprechend skalieren: Wenn wir alle Koeffizienten mit demselben Faktor multiplizieren, bleiben die Beziehungen erhalten, was bedeutet, dass wir bestimmte Teile der Gleichung skalieren können, um diese stärker zu gewichten. Als allgemeine Faustregel gilt: Wenn <span class=\"emphasis\">s</span> = die Länge der längsten möglichen Tour im Graphen und <span class=\"emphasis\">n</span> = die Anzahl der Städte ist, sollten alle Koeffizienten, die die erste Regel durchsetzen, wie folgt berechnet werden:",
        "p-1-1": "Jetzt löst unsere Hamilton-Matrix das TSP für alle Größen korrekt! Hier ist eine Visualisierung des Hamiltonians für ein großes TSP mit <span class=\"emphasis\">n = 8</span>:",
        "p-2": "Der aktualisierte Hamiltonian des <span class=\"emphasis\">n = 4</span>-Beispiels aus Lektion 5 ergibt nun die folgende Lösung:",
        "p-3": "Nun müssen wir daraus die Tour auf dem Graphen wieder ableiten: Der Antwortvektor <span class=\"emphasis\"><i>q<sub>A</sub></i></span> (der die Werte der Variablen <span class=\"emphasis\">a</span> through <span class=\"emphasis\">n</span>) muss zunächst in die Tourmatrix übersetzt werden, indem die Werte einzeln in ein 4x4-Gitter übertragen werden. Durch das Hinzufügen der Zeitschritt- und Städtebezeichnungen in der Tourmatrix wird die Reihenfolge der besuchten Städte sichtbar: <strong> D ➞ B ➞ C ➞ A (➞ D)</strong>. Schauen wir uns den Graphen noch einmal an: Tatsächlich, er hat den kürzesten Weg gefunden!",
        "h3-0": "Wie das Ergebnis ausgewertet wird"
    },
    "lesson-m9UPL": {
        "h2-0": "Wie du eigene Graphen erstellen kannst",
        "p-0": "Natürlich sind solche einfachen Aufgaben nicht wirklich spannend; es ist Zeit, sich mit größeren Netzwerken zu beschäftigen! Jetzt, wo du diesen Kurs erfolgreich abgeschlossen hast, kannst du mit größeren oder sogar selbst entworfenen TSPs experimentieren. Im Reiter <strong style=\"color: #2eb6e8;\">Demo</strong> oben auf der Seite findest du Codebeispiele und Tools zur Interaktion mit den D-Wave-Annealern. Für den Kurs selbst sind keine Programmierkenntnisse notwendig, aber auch wenn du nur wenig Erfahrung hast, probiere es einfach mal aus!",
        "p-1": "Wenn du deine eigenen Netze an den Quantenannealer übermitteln möchtest, musst du sie zunächst in den Hamiltonian umwandeln. Das Tool <span class=\"emphasis\">Graph to Matrix</span>, welches im Reiter <strong style=\"color: #2eb6e8;\">Downloads</strong> zur Verfügung steht, generiert einen Hamiltonian aus einem Graphen als Input, so dass du diesen nicht von Hand berechnen musst.",
        "p-2": "Wenn du die Ergebnisse visualisieren möchtest, lade das Tool <span class=\"emphasis\">Path Visualizer</span> herunter, das die Ergebnisse des Annealers einliest und die entsprechenden Pfade einzeichnet. Sie können zwischen den Lösungen hin- und herwechseln und ihre Energie im Debug-Terminal vergleichen.",
        "li-0": "Markiere deine Städte auf der Leinwand und klicke auf <span class=\"emphasis\">Generate</span>, um die Kanten zu berechnen; der Abstand in Pixeln zwischen jedem Knoten stellt die Kosten der entsprechenden Kante dar.",
        "li-1": "Der Hamiltonian wird automatisch mit der richtigen Skalierung erstellt. Klicke auf <span class=\"emphasis\">Save Hamiltonian...</span>, um ihn auf deinem Computer im NumPy-Matrixformat zu speichern.",
        "li-2": "Klicke auf <span class=\"emphasis\">Save Vertices...</span> , um das Layout deines Graphen zu speichern; dies wird später für die Auswertung der Ergebnisse benötigt."
    },
    "lesson-okhMZ": {
        "h2-0": "Experimentelle Ergebnisse",
        "p-0": "Wenn es darum geht, die Leistung von Quantenalgorithmen zu evaluieren, stellt dies oft eine Herausforderung dar, da diese Methode von Natur aus nicht deterministisch ist. Aufgrund der Arbeit mit Quantenzuständen ist immer ein gewisser Anteil an Zufälligkeit im Spiel. In den folgenden Abschnitten untersuchen wir daher, wie effizient die Lösung des Traveling Salesman-Problems auf Quantencomputern wirklich ist und wie wir diese Leistung verbessern können.",
        "p-1": "Die erste Schwierigkeit ist, TSPs, das zugrunde liegende mathematische Problem, zu quantifizieren. Um vergleichbar zu sein, wird ein einheitlicher Benchmark für Graphen beliebiger Größe benötigt. Eine Möglichkeit, dieses Problem anzugehen, besteht darin, Graphen in Form regelmäßiger Polygone zu verwenden, um den Quantenalgorithmus zu testen, beginnend mit einem Dreieck (da es die einfachste Form mit einem gültigen Hamiltonkreis ist) bis hin zu einem Achteck:",
        "p-2": "Hier wurden regelmäßige Polygone mit einer Kantenlänge von jeweils 50 Einheiten verwendet; die Koordinaten der Eckpunkte können z.B. mit einem Graphikrechner berechnet werden. Diese Formen werden dann in die entsprechenden Hamilton-Matrizen umgewandelt, wobei die Kosten auf 1% (0,5) und die Koeffizienten auf 8 skaliert werden. Das Dreieck zum Beispiel wird in die folgende Form umgewandelt:",
        "p-3": "Unter Verwendung dieser Struktur wurden zwei Problemgruppen erstellt: <i>Einfache Probleme</i>, bei denen die Kosten vernachlässigt werden (so dass die einzige Aufgabe des Annealers darin besteht, eine gültige Tour zu finden), und <i>komplexe Probleme</i>, bei denen die Kosten der Kanten enthalten sind. Ein großer Vorteil der Verwendung von Polygonen besteht darin, dass der Umfang immer den kürzeste Weg darstellt und dadurch die optimalen Kosten leicht im Voraus berechnet werden können (<span class=\"emphasis\">C<sub>n</sub></span> ist die Kostenfunktion für ein Polygon mit <i>n</i> Ecken):",
        "p-4-0": "Nun sind die Testdaten bereit, an den Quantenannealer weitergeleitet zu werden. Bevor wir jedoch den eigentlichen Benchmark durchführen, müssen wir die Hyperparameter abstimmen, d.h. diejenigen statischen Parameter, die die Leistung des Algorithmus direkt beeinflussen und während der Berechnungen nicht geändert werden. Die für unser Problem wichtigsten Parameter sind <span class=\"emphasis\">chain_strength</span> und <span class=\"emphasis\">annealing_time</span>. Übersetzt aus der",
        "p-4-1": "steht <span class=\"emphasis\">chain_strength</span> für die \"Kopplungsstärke zwischen Qubits, die eine Kette [auf der QPU] bilden\", d.h. die Stärke der Magnetfelder, die als Koppler fungieren und die Qubits zwingen, identische Werte anzunehmen. In ähnlicher Weise legt <span class=\"emphasis\">annealing_time</span> die Zeitdauer fest, die die Qubits sich ihrem optimalen Energiezustand annähern dürfen, bevor sie ausgelesen werden und die Superposition kollabiert. Für jeden dieser Werte gibt es Faustregeln, die jedoch nicht immer die besten Ergebnisse liefern müssen. Der Optimierungsprozess ist langwierig und benötigt viele Daten; wenn du am detaillierten Verfahren und den Ergebnissen interessiert bist, kannst du diese vom Reiter <strong style=\"color: #2eb6e8;\">Downloads</strong> beziehen.",
        "p-5": "Nachdem die Hyperparameter optimiert wurden, ist es an der Zeit, die Gesamteffektivität der Quantenlösungsmethode zu evaluieren. Dafür wurde jede Polygongröße der beiden Problemklassen von den hochmodernen <i>D-Wave Advantage</i> (Pegasus-Architektur, 5640 Qubits) und dem Vorgängermodell <i>D-Wave 2000Q</i> (Chimera-Architektur, 2048 Qubits) mit jeweils 10 zufällig generierten Embeddings bewertet. Als Vergleich zu traditionellen Computern wurden die Probleme auch einem <i>Simulated Annealing</i>-Algorithmus unterzogen, einem weit verbreiteten heuristischen Ansatz für Optimierungsprobleme, bei dem die Parameter eines Problems durch zufällige Permutationen verändert werden und eine Abkühlungsfunktion verwendet wird, um zu entscheiden, ob diese beibehalten oder verworfen werden sollen<sup>1</sup>. Eine ausführliche Erklärung würde den Rahmen dieses Kurses sprengen, aber wenn du mehr über das Verfahren im Detail erfahren möchtest, findest du eine Erläuterung über seine Anwendungen bei TSPs",
        "p-6": "In den folgenden Diagrammen sind die Ergebnisse der verschiedenen Ansätze im Vergleich dargestellt. Für jedes Embedding werden die Ergebnisse etwa 500 Mal aus dem Annealer ausgelesen, aber nur die jeweils beste Messung wird gespeichert. Betrachten wir zunächst die Energiedeltas, d.h. die Energiemenge, um die der Quantenannealer die theoretisch optimale Lösung verfehlt hat (das bedeutet: je niedriger, desto besser). Die Balken geben das arithmetische Mittel von 10 Versuchsergebnissen an:",
        "p-7": "Als Nächstes werden die für die Lösung benötigten Rechenzeiten gemessen:",
        "p-8": "Diese Experimente zeigen sofort den Nachteil von Simulated Annealing und anderen traditionellen Berechnungsmethoden: Während sie in der Lage sind, optimale Lösungen für größere Probleme zu finden, ist die für die Berechnung benötigte Zeit sehr lang, in den meisten Fällen mehr als 10 Minuten. Die Quantenannealer hingegen sind in der Lage, die gleichen Aufgaben in Bruchteilen einer Sekunde zu lösen. Das neuere Modell D-Wave Advantage ist über alle Problemgrößen hinweg schneller als der 2000Q, aber die Rechenzeit schwankt stärker und ist weniger konsistent. Zusammenfassend lässt sich sagen, dass unser Quantenalgorithmus für jede Problemgröße und -komplexität mindestens eine korrekte Lösung finden kann, mit Ausnahme des komplexen Problems <span class=\"emphasis\">n = 8</span>.",
        "p-9-0": "Alle Python-Dateien, die zur Durchführung der Experimente verwendet wurden, sowie die Rohdaten der Messungen sind im",
        "p-9-1": "und dem Reiter <strong style=\"color: #2eb6e8;\">Downloads</strong> verfügbar.",
        "Link-0": "Referenzdokumentation",
        "Link-1": "auf dieser Seite",
        "Link-2": "GitHub-Repo des Projekts"
    },
    "lesson-_Z9Gv": {
        "h2-0": "Wo liegen die Grenzen?",
        "p-0": "Obwohl die unschlagbare Geschwindigkeit dieses Quantenalgorithmus ihn sehr attraktiv macht, hat er auch einige große Einschränkungen. Manche davon ergeben sich einfach aus dem heutigen Stand der Technologie und werden wahrscheinlich durch künftige Fortschritte auf dem Gebiet des Quantencomputings überwunden werden. Da ein Graph mit <i>n</i> Knoten zunächst in eine Tour-Matrix mit <i>n<sup>2</sup></i> Elementen umgewandelt wird, steigt die Zahl der benötigten Qubits und Verbindungen quartisch, d.h. um einen Exponenten von vier. Analog zur traditionellen Informatik könnte man die <i>Komplexität</i> des Quantenalgorithmus wie folgt charakterisieren:",
        "p-1": "Mit zunehmender Anzahl der miteinander verbundenen Qubits steigt die Anzahl der physikalischen Qubits, die zu logischen Qubits kombiniert werden müssen, wodurch die Wahrscheinlichkeit falscher Ergebnisse exponentiell ansteigt. Aus diesem Grund ist <span class=\"emphasis\">n = 8</span> ungefähr die Grenze dessen, was das aktuelle D-Wave Advantage-System lösen kann, da jedes Qubit nur mit 15 anderen verbunden sein kann. Mit jeder hinzugefügten Stadt wird auch das Embedding größer, bis schließlich der gesamte Platz auf der QPU aufgebraucht ist. Die Abbildung rechts zeigt die Fläche, den das Embedding des Problems mit der Größe <span class=\"emphasis\">n = 8</span> auf der QPU einnimmt, mit Ketten, die teilweise 8-9 Qubits lang sind. Aufgrund zunehmender Rechnerkapazitäten und komplexerer Architekturen wird diese Einschränkung jedoch in Zukunft wahrscheinlich zunehmend irrelevant werden.",
        "p-2": "Die <i>Matrixdichte</i>, d.h. der Anteil der Matrixeinträge, die keine Nullen sind, spielt ebenfalls eine Rolle für die Recheneffizienz. Je spärlicher der Hamiltonian ist, d.h. je weniger Ketten im Verhältnis zur Problemgröße benötigt werden, desto einfacher ist es für den Quantencomputer, das QUBO-Problem zu lösen. Da die von diesem Quanten-TSP-Algorithmus erzeugten Matrizen relativ dicht sind, wird die Leistungsgrenze bei kleineren Problemgrößen als üblich erreicht. Diese Einschränkung ist weitaus relevanter, da noch nicht absehbar ist, ob die Trefferquote von Quantenannealern allein durch Skalierung erhöht werden kann.",
        "p-3": "Bei der Übermittlung von Problemen an die QPU wird das Embedding automatisch von D-Wave Ocean generiert, um Zeit zu sparen, insbesondere bei größeren Problemen. Allerdings ist auch dies eine komplexe Optimierungsaufgabe, weshalb die Algorithmen wahrscheinlich nicht die beste Lösung finden werden. Wenn wir die Effizienz maximieren wollten, wäre es daher theoretisch möglich, das QUBO-Problem manuell zu embedden und jedes Qubit und jede Verbindung von Hand zu setzen. Wenn du an der technischen Seite interessiert bist, findest du die Details in der",
        "p-4": "Dieses Vorhaben erfordert jedoch nicht nur eine große Menge weiterer mathematischer Berechnungen, sondern auch eine eingehende und fundierte Kenntnis der QPU-Topologie. Das Verfahren ist zeitaufwendig und muss für jede einzelne Problemgröße wiederholt werden, so dass es sich nur für einige kleine Probleme lohnt.",
        "h3-0": "Ein Lösungsansatz: Manuelles Embedding",
        "Link-0": "offizielle Dokumentation"
    },
    "lesson-ufr4r": {
        "h2-0": "Möglichkeiten zur Verbesserung und Optimierung",
        "p-0": "Die Erläuterung und Bewertung der Methode ist abgeschlossen; sie ist jedoch eher als Grundlage für weitere algorithmische Ansätze dieser Art zu betrachten und kann mit einigen Anpassungen auch optimiert und erweitert werden.",
        "p-1": "Da es sich bei TSP-Touren um geschlossene Schleifen handelt, die jede Stadt besuchen, kann der Startpunkt beliebig festgelegt werden. Wenn wir also theoretisch dem Quantenannealer diese Entscheidung abnehmen und den Startpunkt z.B. auf <span class=\"emphasis\">A</span> setzen, können die erste Zeile und die erste Spalte der Tour-Matrix weggelassen werden, da diese Stadt im weiteren Verlauf des Pfades garantiert nicht mehr besucht wird:",
        "p-2": "Darüber hinaus muss die Kostenfunktion so angepasst werden, dass der Weg von <span class=\"emphasis\">A</span> nach <span class=\"emphasis\">B</span>, <span class=\"emphasis\">A</span> nach <span class=\"emphasis\">C</span> usw. nur vom zweiten besuchten Knoten abhängt. Dieser Ansatz reduziert die Größe der Tourmatrix um 1, was bedeutet, dass die Anzahl der Städte, für die der Annealer eine Lösung finden kann, um 1 über seine normale Rechenleistung hinaus erhöht werden kann. Diese und andere Optimierungen lohnen sich jedoch langfristig nur, wenn sie die Anzahl der Nicht-Null-Einträge in der Hamilton-Matrix tatsächlich reduzieren können.",
        "p-3": "Um den Algorithmus für reale Alltagssituationen anwendbarer zu machen, wäre es auch möglich, ihn über den Rahmen des traditionellen Traveling Salesman-Problems hinaus für <i>unvollständige Graphen</i> (bei denen nicht alle Knoten miteinander verbunden sind) und <i>gerichtete Graphen</i> (bei denen bestimmte Kanten nur in eine Richtung durchlaufen werden können oder je nach Überquerungsrichtung unterschiedliche Kosten haben) zu erweitern:",
        "p-4": "Wenn eine Verbindung zwischen zwei Städten nicht existiert (z.B. aufgrund der Struktur eines Straßennetzes), muss der Quantenannealer um jeden Preis davon abgehalten werden, sie in die Lösung einzubeziehen. Um eine nicht existierende Kante zu repräsentieren, könnte man sie also mit einer massiven Strafe belegen, so dass die niedrigsten Kosten nie erreicht werden, wenn diese Teil der Tour ist. In der mathematischen Literatur wird dies üblicherweise mit einem \"&#8734;\" (Unendlichkeitssymbol) ausgedrückt, aber in unserem Fall ist eine hohe ganze Zahl besser geeignet.",
        "p-5": "Um in einem gerichteten Graphen unterschiedliche Kosten bei unterschiedlichen Überquerungsrichtungen darzustellen, muss man bei der Formulierung der QUBO-Gleichung nur zwischen der Reihenfolge unterscheiden, in der die Knoten besucht werden können. Im folgenden Beispiel hat die Kostenfunktion unterschiedliche Werte, je nachdem, ob der Weg von A nach C oder von C nach A führt:",
        "p-6": "Die vorherige Methode kann genutzt werden, um darzustellen, dass eine Verbindung nur in einer Richtung besteht: Die andere Richtung wird mit hohen Kosten belegt. Es ist jedoch zu beachten, dass bei unvollständigen und gerichteten Graphen der Quantenannealer nur dann eine gültige Lösung ausgeben kann, wenn tatsächlich ein Hamiltonkreis existiert.",
        "i-0": "Beispiele für einen unvollständigen Graphen (links) und einen gerichteten Graphen (rechts)"
    },
    "lesson-U7uiF": {
        "h2-0": "Schlussgedanken",
        "p-0": "Da jährlich neue Meilensteine erreicht werden, ist Quantencomputing ist eine sich rasant entwickelnde Technologie, die unser Leben stark beeinflussen wird. Es ist derzeit eines unserer vielversprechendsten Lösungen für die Klasse der Optimierungsproblem insgesamt, weshalb sich die weitere Forschung an Quantenalgorithmen für das Traveling Salesman-Problem und andere Aufgaben auf jeden Fall lohnt.",
        "p-1": "Dennoch ist es wichtig, auch die Grenzen anzuerkennen. Bis diese Methode auf alltags- und industrierelevante Aufgabenstellungen (&#8764;50-100 Städte) angewandt werden kann, müssen noch viele Fortschritte gemacht werden. Im Gegensatz zu seiner (noch) begrenzten Kapazität und seiner Fehlerquote hat der Quantenansatz jedoch ein großes Potenzial für den Einsatz im wirklichen Leben, da in der Industrie allermeistens nicht unbedingt die beste, sondern eine gute Lösung benötigt wird und die Geschwindigkeit, mit der sie gefunden wird, viel wichtiger ist als ihre Genauigkeit. Die Lösung des TSP mit Quantenannealern stellt daher eine große Chance dar, die Herstellungs-, Logistik- und Forschungsprozesse in Zukunft erheblich beschleunigen kann.",
        "p-2-0": "Ich möchte allen, die mich bei dieser Forschung unterstützt haben, herzlich danken, insbesondere",
        "p-2-1": "und dem",
        "p-3": "Ein besonderer Dank geht an <strong>Dennis Willsch</strong> und <strong>Kristen Michielsen</strong> vom JSC für ihre großzügige Unterstützung, Beratung und Koordination.",
        "p-4": "Danke auch an <strong>René Grünbauer</strong> vom Gymnasium der Regensburger Domspatzen, der das Projekt durch seine hervorragenden Ideen ermöglicht hat.",
        "h3-0": "Danksagungen"
    },
    "lesson-store": {
        "title": {
            "BxESn": "Das Traveling Salesman-Problem: Eine Einführung",
            "m2MJl": "QUBO-Probleme",
            "xR66u": "Wie funktionieren Quantenannealer?",
            "yV8O6": "Umwandlung des Traveling Salesman-Problems für Quantenannealer",
            "0nRrT": "Formulierung der QUBO-Gleichung",
            "EFTOp": "Von Koeffizienten zur Hamilton-Matrix",
            "m9UPL": "Wie du eigene Graphen erstellen kannst",
            "okhMZ": "Experimentelle Ergebnisse",
            "_Z9Gv": "Wo liegen die Grenzen?",
            "ufr4r": "Möglichkeiten zur Verbesserung und Optimierung",
            "U7uiF": "Schlussgedanken",
            "Z30Ce": "Graphentheorie"
        },
        "desc": {
            "BxESn": "Du bist der Vertreter eines großen Unternehmens, welches dich auf eine Geschäftsreise durch seine wichtigsten Standorte schickt. Zufälligerweise befinden sich ...",
            "m2MJl": "Bevor wir uns mit der Funktionsweise von Quantenannealern befassen können, müssen wir ein grundlegendes Konzept verstehen. Damit ein Quantenannealer eine Aufgabe ...",
            "xR66u": "Mit den mathematischen Grundlagen ausgestattet, können wir uns nun der Frage stellen: Wie kommen wir von einer Eingabe zu einem Ergebnis? Der Prozess der ...",
            "yV8O6": "Nun sind wir beim Hauptteil des Kurses angelangt. Die Erstellung eines Quantenlösungsverfahrens für das TSP ist ein spannendes Beispiel für die ...",
            "0nRrT": "Aus der beispielhaften Tourmatrix der vorigen Lektion lassen sich folgende Regeln für die Belegung ableiten: 1. Es ist genau eine Belegung ...",
            "EFTOp": "Wie in Kapitel 2 besprochen, müssen die Koeffizienten aus der QUBO-Gleichung in die Hamilton-Matrix übertragen werden, um eine gültige Eingabe für ...",
            "m9UPL": "Wenn du deine eigenen Netze an den Quantenannealer übermitteln möchtest, musst du sie zunächst in den Hamiltonian umwandeln. Das Tool ...",
            "okhMZ": "Wenn es darum geht, die Leistung von Quantenalgorithmen zu evaluieren, stellt dies oft eine Herausforderung dar, da diese Methode von Natur aus nicht ...",
            "_Z9Gv": "Obwohl die unschlagbare Geschwindigkeit dieses Quantenalgorithmus ihn sehr attraktiv macht, hat er auch einige große Einschränkungen. Manche davon ...",
            "ufr4r": "Die Erläuterung und Bewertung der Methode ist abgeschlossen; sie ist jedoch eher als Grundlage für weitere algorithmische Ansätze dieser Art zu betrachten ...",
            "U7uiF": "Da jährlich neue Meilensteine erreicht werden, ist Quantencomputing ist eine sich rasant entwickelnde Technologie, die unser Leben stark ...",
            "Z30Ce": "Computer können nur mit Zahlen arbeiten, also müssen wir auch mit ihnen umgehen. Wir haben bereits unbewusst ein Schlüsselkonzept der Lösungsmethode gezeichnet mit ..."
        }
    },
    "download-store": {
        "title": {
            "WQnhY": "Graph To Matrix - TSPQ",
            "2Jmfy": "Path Visualizer - TSPQ",
            "APf1g": "Tutorial-Notebook",
            "HQerk": "Ergebnisdatenbank",
            "Pv9Rq": "Resultsbook"
        },
        "desc": {
            "WQnhY": "Ein Hilfsprogramm zum visuellen Entwerfen und Zeichnen von Graphen und zum Exportieren ihrer Hamilton-Matrix mit einem Klick als Eingabe für Quantenannealer",
            "2Jmfy": "Ein Hilfsprogramm zum Einlesen und Visualisieren der Lösungen von Quantenannealern für Traveling Salesman-Probleme auf einer Zeichenfläche",
            "APf1g": "Ein interaktives Python-Notebook für diejenigen, die sich für den Code dieses Kurses interessieren, einschließlich Anleitungen für die Interaktion mit den D-Wave-Quantenannealern",
            "HQerk": "Diese Datei enthält die Rohdaten der Messungen, die zur Evaluierung der Leistung des TSP-Quantenalgorithmus durchgeführt wurden; nützlich für die Erstellung eigener Diagramme, kann von diversen JSON-Libraries gelesen werden",
            "Pv9Rq": "Alle relevanten experimentellen Daten und Benchmarking-Ergebnisse, zusammengefasst in einem einzigen Dokument; enthält die Hamiltonians und Datenplots für Graphen aller lösbaren Größen, frei benutzbar für Print-Publikationen"
        }
    },
    "references": "Referenzen",
    "ref_access": "letzter Zugriff",
    "button-0": "Starten",
    "button-1": "Herunterladen",
    "footer": "Erstellt mit"
}